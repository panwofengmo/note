1. STL
	+ STL 是一个包含不同数据结构和算法的库，用于有效存储和操作数据
	+ 最常见的数据结构
		+ 向量(vector)
		+ 列表(list)
		+ 队列(queue)
		+ 栈(stack)
		+ 映射(map)
		+ 集合(set)
		+ 双端队列(deque)
	+ 容器：提供数据存储方式的数据结构，如vector、list
	+ 迭代器：用于访问数据结构元素的对象
	+ 算法：` sort()`和` find()`等函数，它们通过迭代器对数据结构执行操作

2. 向量(vector)
	+ 一种可动态调整大小的数组，支持随机访问
	+ 常用操作
		+ `push_back()`：在向量末尾添加元素
		+ `pop_back()`：删除向量末尾的元素
		+ `size()`：返回向量中元素的数量
		+ `empty()`：检查向量是否为空; 为空时返回true
		+ `front()`：返回向量的第一个元素
		+ `back()`：返回向量的最后一个元素
		+ `at()`：访问指定位置的元素
		+ `[]`：访问指定位置的元素
		+ `begin()`：返回指向向量第一个元素的迭代器
		+ `end()`：返回指向向量最后一个元素的迭代器

3. 列表(list)
	+ 一种双链表，在列表的开头和末尾添加或删除元素；不支持随机访问；则不允许使用`my_list[1]`访问元素
	+ 常用操作
		+ `push_back()`：在列表末尾添加元素
		+ `push_front()`：在列表开头插入元素
		+ `pop_back()`：删除列表末尾的元素
		+ `pop_front()`：删除列表开头的元素
		+ `size()`：返回列表中元素的数量
		+ `empty()`：检查列表是否为空; 为空时返回true
		+ `front()`：返回列表的第一个元素
		+ `back()`：返回列表的最后一个元素
		+ `begin()`：返回指向列表第一个元素的迭代器
		+ `end()`：返回指向列表最后一个元素的迭代器
	+ 遍历
		+ 使用 for-each 循环: ` for (string car : cars)`
		+ 使用迭代器: `for (list<string>::iterator it = my_list.begin(); it != my_list.end(); ++it)`

4.  栈(stack)
	+ 一种先进后出(FIFO)的数据结构，只能在栈顶添加或删除元素，不能随机访问，只能访问栈顶的元素
	+ 头文件：`#include <stack>`
	+ 常用操作
		+ `push()`：在栈顶添加元素
		+ `pop()`：删除栈顶的元素, 没有返回值
		+ `size()`：返回栈中元素的数量
		+ `empty()`：检查栈是否为空; 为空时返回true
		+ `top()`：返回栈顶的元素，不删除该元素；还可以修改栈顶元素：` cars.top() = "Audi"`

5. 队列(queue)
	+ 一种先进先出(FIFO)的数据结构，只能在队尾添加元素，只能在队头删除元素，不能随机访问，只能访问队头和队尾的元素
	+ 头文件：`#include <queue>`
	+ 常用操作
		+ `push()`：在队尾添加元素
		+ `pop()`：删除队头的元素, 没有返回值
		+ `size()`：返回队列中元素的数量
		+ `empty()`：检查队列是否为空; 为空时返回true
		+ `front()`：返回队列的第一个元素
		+ `back()`：返回队列的最后一个元素

6. 双端队列(deque)
	+ 一种双端队列，在双端队列的开头和末尾添加或删除元素；支持随机访问,即允许使用`my_deque[1]`访问元素
	+ 常用操作
		+ `push_back()`：在双端队列末尾添加元素
		+ `push_front()`：在双端队列开头插入元素
		+ `pop_back()`：删除双端队列末尾的元素
		+ `pop_front()`：删除双端队列开头的元素
		+ `size()`：返回双端队列中元素的数量
		+ `empty()`：检查双端队列是否为空; 为空时返回true
		+ `front()`：返回双端队列的第一个元素
		+ `back()`：返回双端队列的最后一个元素
		+ `begin()`：返回指向双端队列第一个元素的迭代器
		+ `end()`：返回指向双端队列最后一个元素的迭代器
		+ `at()`：访问指定位置的元素
		+ `[]`：访问指定位置的元素
	+ 遍历
		+ 使用 for-each 循环: ` for (string car : my_deque)`
		+ 使用 for 循环: ` for (int i = 0; i < cars.size(); i++)`
		+ 使用迭代器: `for (deque<string>::iterator it = my_deque.begin(); it != my_deque.end(); ++it)`

7. 集合(set)
	+ 一种有序的集合，集合中的元素是唯一的，不能重复
	+ 头文件：`#include <set>`
	+ 集合里的元素：
		+ 会自动按升序排序
		+ 唯一性，不能重复
		+ 可以添加和移除，但不能修改已存在元素的值
		+ 不能通过索引号访问，因为顺序是基于排序而非索引
	+ 常用操作
		+ `insert()`：插入元素: `my_set.insert(10);`
		+ `erase()`：删除元素: `my_set.erase(10);`
		+ `size()`：返回集合中元素的数量
		+ `empty()`：检查集合是否为空; 为空时返回true
		+ `begin()`：返回指向集合第一个元素的迭代器
		+ `end()`：返回指向集合最后一个元素的迭代器
		+ `find()`：查找元素
		+ `count()`：返回元素的数量
		+ `clear()`：清空集合
	+ 按降序排序集合(` greater<type>`)
	```
		// 按降序排序集合元素
		set<int, greater<int>> numbers = {1, 7, 3, 2, 5, 9};
		// 打印元素
		for (int num : numbers) {
			cout << num << "\n";
		}
	```
	+ 遍历
		+ 使用 for-each 循环: ` for (int i : my_set)`
		+ 使用迭代器: `for (set<int>::iterator it = my_set.begin(); it != my_set.end(); ++it)`

