# 一、const 那些事
1. const对象默认为文件局部变量
	+ 例：const int a = 10; 在文件a.cpp中定义，如果b.cpp要是用该变量，需要在a.cpp声明后才能使用，` extern const int a = 10;`
	+ 相应代码：CPlusPlusThings-master/basic_content/const/extern_const/

2. 指针与const
	+ 如果const位于*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；
	+ 如果const位于*的右侧，const就是修饰指针本身，即指针本身是常量。
	+ const指针指向的值能修改，但指向不能修改
		+ error: ` int * const ptr=&num;    ptr = &num1;`
		+ correct: ` int * const ptr=&num;    *ptr = 1;`

3. 函数中使用const
	+ 是否应将void func(int x) 改写为void func(const int &x)
		+ 完全没有必要，因为内部数据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当
	+ 对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率
		+ 例：` 将void func(myClass a) 改为void func(const myClass &a)`

4. 类中使用const
	+ const对象只能访问const成员函数,而非const对象可以访问任意的成员函数,包括const成员函数
		+ 参考代码：CPlusPlusThings-master/basic_content/const/class_const/first_example
		+ 如：class apple，只能调用const的成员函数，不能调用普通函数
		+ ` const Apple b(3);    b.add(); // error`
	+ 在C++中，static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化
		+ 在类中声明：` static int ap;`
		+ 在类实现文件中使用(***.cpp)：` static int ap;`


# 二、static那些事
1. 静态变量空间分配
	+ 当变量声明为static时，空间将在程序的生命周期内分配。即使多次调用该函数，静态变量的空间也只分配一次，前一次调用中的变量值通过下一次函数调用传递
	+ 参考代码：` CPlusPlusThings-master/basic_content/static/static_demo.cpp`

2. 类中的静态变量应由用户使用类外的类名和范围解析运算符显式初始化
	+ 正确：` int Apple::i = 1;`
	+ 错误：` Apple obj1;    obj1.i =2;`		//error:编译时会报错
	+ 参考代码：
		+ CPlusPlusThings-master/basic_content/static/static_error_variable.cpp
		+ CPlusPlusThings-master/basic_content/static/static_variable.cpp

3. 类对象为静态(static Apple obj;)
	+ 静态对象的范围是贯穿程序的生命周期
	+ 对象在程序结束后才会被析构，超过作用域不会被析构
	+ 参考代码：
		+ CPlusPlusThings-master/basic_content/static/nostatic_class.cpp
		+ CPlusPlusThings-master/basic_content/static/static_class.cpp

4. 类中的静态函数
	+ 就像类中的静态数据成员或静态变量一样，静态成员函数也不依赖于类的对象
	+ 建议使用类名和范围解析运算符调用静态成员
		+ ` Apple::printMsg();`
	+ 允许静态成员函数仅访问静态数据成员或其他静态成员函数，它们无法访问类的非静态数据成员或成员函数!!!

5. static还有限定访问范围的作用
	+ 例：A.cpp有个static const char* msg = "Hello World!\n";
	+ B.cpp想使用这一变量时，会编译报错
	+ static 相当于限定于本文件的全局变量


# 三、this指针那些事
1. this作用域是在类内部
	+ 当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数

2. this在成员函数的开始执行前构造，在成员的执行结束后清除

3. this的类型
	+ 在const成员函数内，this被解析成` const A * const this`
	+ 在非const成员函数内，this被解析成 ` A * const this`


# 四、inline那些事
1. 类中定义了的函数是隐式内联函数

2. 声明要想成为内联函数，必须在实现处(定义处)加inline关键字
	+ ` inline void A::f1(int x) {...}`

3. 内联能提高函数效率，但并不是所有的函数都定义成内联函数
	+ 内联是以代码膨胀(复制)为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率
	+ 不宜用内联
		+ 函数体内的代码比较长
		+ 函数体内出现循环

4. 虚函数（virtual）可以是内联函数（inline）吗
	+ 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联
	+ 内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码


# 五、类大小计算
1. 空类的大小为1字节
	+ ` class A{};    sizeof(A);    //sizeof(A) = 1`


# 六、函数指针那些事
1. void (*pFun)(int);
	+ pFun为一个变量，这个变量是个指针，指向返回值为空和参数为int的函数的指针

2. typedef void (*func)(void);
	+ func是一种类型，类型为指向返回值为空和参数为空的函数的指针
	+ ` func pfun = myfunc;		//pfun为变量`

