# 一、例子  
1. `^[0-9]+abc$`  
      + **`^`** 为匹配输入字符串的开始位置。
      + `[0-9]+`匹配多个数字， `[0-9]` 匹配单个数字，`+` 匹配一个或者多个。
      + `abc$`匹配字母 `abc` 并以 `abc` 结尾，`$` 为匹配输入字符串的结束位置
      + 功能：匹配多个数字且以`abc`结尾的字符  

2. `^[a-zA-Z0-9_-]{3,15}$`  
   + `^` 表示匹配字符串的开头。
   + `[a-zA-Z0-9_-]` 表示字符集，包含小写字母、大写字母、数字、下划线和连接字符`-`。
   + `{3,15}`表示前面的字符集最少出现 3 次，最多出现 15 次，从而限制了用户名的长度在 3 到 15 个字符之间。
   + 功能：只允许用户名包含**字符、数字、下划线和连接字符 `-`**，并设置用户名的长度在3-15之间
   + 匹配成功："runoob"、"run-oob"
   + 匹配失败："ru"、"runoob$"

3. ` set (.-)\r\n`
	+ 根据` string.match(read_data, "set (.-)\r\n")`而来
	+ 功能：从read_data中匹配以"set "开头、以"\r\n"结尾的字符串，并返回中间的非贪婪匹配内容(.-部分)
	+ ` "set "`：匹配固定前缀
	+ ` (.-)`：非贪婪捕获任意字符(最短可能匹配)
	+ ` \r\n`：匹配固定后缀(Windows换行符)

4. ` (.-)\r\n(.*)`
	+ 功能：匹配两行文本(以\r\n分隔),
		+ 第一行：非贪婪匹配任意内容（保存在第一个捕获组）
		+ 第二行：贪婪匹配剩余所有内容（保存在第二个捕获组）
	+ ` (.-)`：
		+ 非贪婪捕获任意字符(最短可能匹配)
		+ ` ()`表示捕获分组，会将匹配的内容保存起来供后续使用
		+ ` .`匹配除换行符外的任意单个字符
		+ ` -` 是一个量词修饰符，表示"非贪婪匹配"，会尽可能少地匹配字符
	+ ` \r\n`：匹配Windows系统中的换行符（回车+换行）,在Unix/Linux系统中换行符通常是\n，Mac OS早期版本使用\r
	+ ` (.*)`：.* 表示匹配任意数量（包括零个）的任意字符（除换行符外）,这里是贪婪匹配，会尽可能多地匹配字符
	+ 例子：
		```
		local readbuff = "login,101,134\r\nwork\r\nwo"
		local msgstr, rest = string.match(readbuff, "(.-)\r\n(.*)")
		//msgstr = "login,101,134"
		//rest = "work\r\nwo"
		local readbuff = "wo"
		local msgstr, rest = string.match(readbuff, "(.-)\r\n(.*)")
		//msgstr = nil, rest = nil
		```


# 二、正则表达式元字符和特性  
1. **字符匹配**
   + 普通字符：普通字符按照字面意义进行匹配，例如匹配字母 "a" 将匹配到文本中的 "a" 字符。
   + 元字符：元字符具有特殊的含义，例如 \d 匹配任意数字字符，\w 匹配任意字母数字字符，. 匹配任意字符（除了换行符）等。  
  
2. **量词**
   + *：匹配前面的模式零次或多次。
   + +：匹配前面的模式一次或多次。
   + ?：匹配前面的模式零次或一次。
   + {n}：匹配前面的模式恰好 n 次。
   + {n,}：匹配前面的模式至少 n 次。
   + {n,m}：匹配前面的模式至少 n 次且不超过 m 次。
3. **字符类**
[ ]：匹配括号内的任意一个字符。例如，[abc] 匹配字符 "a"、"b" 或 "c"。
[^ ]：匹配除了括号内的字符以外的任意一个字符。例如，[^abc] 匹配除了字符 "a"、"b" 或 "c" 以外的任意字符。
边界匹配
^：匹配字符串的开头。
$：匹配字符串的结尾。
\b：匹配单词边界。
\B：匹配非单词边界。
分组和捕获
( )：用于分组和捕获子表达式。
(?: )：用于分组但不捕获子表达式。
特殊字符
\：转义字符，用于匹配特殊字符本身。
.：匹配任意字符（除了换行符）。
|：用于指定多个模式的选择。