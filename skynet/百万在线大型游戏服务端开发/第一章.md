1. 搭一个简单的服务器
	+ 相关代码1-1，相关代码在github上，路径为million_online_code/chapter_1/code_1.cpp
	+ 代码分析
		1. 创建 socket
			+ 使用socket函数，获得套接字server_fd
		2. 设置地址重用选项
			+ 使用setsockopt函数
		3. 绑定指定IP和端口
			+ 创建sockaddr_in变量address，清空变量数据，设置ip和端口
			+ 使用inet_pton函数将字符串的ip地址转换成二进制并复制到address去
			+ 使用bind函数，将套接字server_fd和地址变量address绑定
		4. 监听套接字
			+ 使用listen函数监听套接字server_fd
		5. 接受客户端连接(单连接示例)
			+ 创建sockaddr_in变量，当有新连接时，将连接的信息存放到这一变量中
			+ 使用accept函数挂起，等待新连接接入
			+ 当新连接到来时，可以使用inet_ntop函数将sockaddr_in的ip地址提取并
		6. 使用send给新连接发送数据
		7. 关闭连接
	
2. 单线事件模型
	+ “单线”指的是单线程，“事件”指的是事件触发
	+ 专业术语叫Reactor模型：即当新连接、断开连接、收到数据这些事件到来时会触发某段代码

3. 根据交互性决定进程间的通信
	+ 三个层次的交互：1.同一个进程内；2.同一台物理机；3.跨物理机
	+ 以MMORPG为例
		1. 同一个场景的角色交互很强，每走一步都要让对方知道，可以在同一个程序中处理同一个场景逻辑；
		2. 不同场景的角色交互较弱，只有聊天、好友、公会这些功能需要交互，可以将同一个服务器的玩家都放在同一台物理机上处理；
		3. 不同服务器的玩家交互很少，可以放到不同的物理机上

4. 一致性问题
	+ 进程间的数据可能会存在不一致的情况
	+ 例子：如A玩家在A进程，B玩家在B进程，当A玩家向B玩家购买道具时，可能会出现B玩家扣除道具成功，而A玩家添加道具失败的情况
	+ 一致性问题是分布式系统的一大难题，在游戏业务中，开发者一般会把一致性问题抛给具体业务去处理；如上面的情况，会使用唯一编号的方式解决

5. 多进程为什么能提升性能
	+ 因为单个程序中可能会存在一些阻塞语句让CPU空闲，开启多个程序可以填补CPU的空闲时间
	+ 阻塞是不占用CPU的

6. 线程占用资源
	+ CPU切换线程需要做很多工作，它执行一条语句大概需要几纳秒，完成一次线程切换大概需要几微秒，花销较大
	+ 在普通的计算机中，虽然操作系统理论上可以支持（近乎）无限的线程数，但实际上运行几百个性能就很不好了

7. 分布式程序的缺点
	+ 实现分布式程序的前提是游戏逻辑能够分割。如果游戏规则复杂，各个功能紧密相连，则不容易找到分割的方案

8. 万物皆Actor
	+ 合理分割功能是分布式模型的一大难点，而Actor并发模型中，每个Actor相互隔离，只通过消息通信，具有天然的
并发性