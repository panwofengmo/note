# 一、学习游戏服务器框架-skynet的最佳指南
1. skynet框架：actor框架 + 基础组件(网络接入方案、lua虚拟机实现抽象的进程、时间轮)
2. 编程原则：不要使用共享内存进行通信，而要通过通信来共享内存 
    + 即：要通过通信来交换数据
3. actor并发模型：actor + 消息 + 协程
   1. actor：lua虚拟机 + 消息队列(按照消息到达的先后顺序) + 回调函数
       + lua虚拟机处理业务逻辑，然后将相应的消息放到消息队列中。然后c层会处理消息队列中的消息，并调用消息里面的回调函数
   2. 消息：网络消息、actor之间发送消息、定时消息
      + 网络消息：某个fd消息必然会路由到某个actor中去处理
      + actor之间发送消息：通过消息共享、交换数据
      + 定时消息：处理某些延时任务
      + 业务逻辑是异步处理方式
        + 同步处理方式：A发送消息之后会阻塞等待，等B处理完消息后再唤醒A
          + 而因为异步会陷入回调地狱，因此导致业务很麻烦
          + 而同步不能阻塞线程，效率会很差，但必须要阻塞一个执行体，因此**协程**应运而生
        + 异步处理方式：会导致嵌套回调，从而陷入回调地狱

# 二、actor的编程思路
1. 要从业务角度去划分actor进程
2. 启动skynet:
  + 在存放skynt文件夹和skynet_game_1文件夹的同级目录，调用./skynet/skynet ./skynet_game_1/config.game
  + 客户端连接到skynet：telnet 127.0.0.1 8888
3. 各个模块负责的功能
   + main.lua: 调起redis和hall, 将监听fd与accept函数绑定
   + agent.lua: 注册、登陆、准备游戏
   + room.lua: 负责猜数字游戏的整个完整模块：开始、猜数字、结束、上线、掉线
   + hall.lua: 负责拉玩家到房间

# 三、底层运行逻辑：actor是如何调度的
1. 一个skynet节点,也就是一个skynet进程。他启动的时候会创建多个线程,他们是
	网络线程：  接收skynet外部的网络请求，然后push到服务的队列。
				当服务需要把数据发送给外部时,实质上是 服务--->网络线程--->外部
	定时器线程：把定时器消息push到某个服务。当服务在处理定时器消息时,就可以认为是定时器事件触发了。
	监听线程：主要是发现工作线程有没有死循环
	多个工作线程(线程池)：驱动服务处理消息
2. 如何分析线程池
	1. 将线程池中的生产者和消费者全部列举出来
		+ 生产者：网络线程(将外界传进来的消息放到队列中)、定时线程(将某些延时线程放到队列中)、线程池(actor之间发送消息)
		+ 消费者：线程池(处理消息)
	2. 线程池怎么唤醒的？怎么休眠的？
    + 休眠：消息队列没消息(pthread_cond_wait(&m->cond, &m->mutex);) 
        + 在thread_worker函数中，if (q == NULL)里面进行休眠
    + 唤醒：有新的消息到达消息队列中，线程池会唤醒线程
      + 定时消息：在thread_timer函数中，调用wakeup函数进行唤醒
      + 网络消息：在thread_socket函数中，调用wakeup函数进行唤醒
3. 全局消息队列
	+ 每个节点存放的是指向actor的消息队列的指针/引用，活跃的actor(有消息的actor)
4. 结合源码分析
	+ 线程池中工作线程工作内容：thread_worker函数
	+ 运行回调函数
  	+ reserve_msg = ctx->cb(ctx, ctx->cb_ud, type, msg->session, msg->source, msg->data, sz);	//运行回调函数，根据
  	+ 能根据上下文(ctx)找到相应的actor，并将msg->data作为回调函数的参数



进度：01:12:00